import math
from typing import List, Optional, Tuple

import torch
import torch.nn.functional as F

from . torch_spline_interpolation_beta import *
from . torch_spline_interpolation_delta import *
import numpy as np
import gc


#UNCOMMENT WHEN DEBUGGING
# Reload the module 
#import importlib
#import sys
#importlib.reload(sys.modules['torch_spline_interpolation_delta'])
#importlib.reload(sys.modules['torch_spline_interpolation_beta'])



"""
All based on https://github.com/gwpy/gwpy/blob/v3.0.8/gwpy/signal/qtransform.py
The methods, names, and descriptions come almost entirely from GWpy.
This code allows the Q-transform to be performed on batches of multi-channel
input on GPU.
"""
##########################################################################
# Winodow functions. To be moved to Annalisa.py
##########################################################################
import math
import torch
import torch.nn.functional as F
from typing import List, Optional, Tuple, Union

# ============================
# External Window Functions
# ============================

def planck_taper_window_range(N: int, epsilon: float, x_min: float = -1, x_max: float = 1, device: str = 'cpu') -> torch.Tensor:
    """
    Constructs a Planck-taper window defined over an arbitrary range [x_min, x_max].
    Internally, it maps the coordinate linearly to the canonical range [-1,1] and then applies
    your provided Planck-taper formula.
    
    Args:
        N (int): Window length (number of samples).
        epsilon (float): Taper fraction (0 < epsilon < 0.5).
        x_min (float): Minimum value of the input coordinate.
        x_max (float): Maximum value of the input coordinate.
        device (str): Device.
        
    Returns:
        Tensor: A 1D tensor of shape [N] representing the Planck-taper window.
    """
    # Create coordinate x in [x_min, x_max]
    x = torch.linspace(x_min, x_max, steps=N, device=device, dtype=torch.float32)
    # Map x linearly to the canonical domain [-1,1]
    x_canonical = 2 * (x - x_min) / (x_max - x_min) - 1
    # Map to y in [0,1]
    y = (x_canonical + 1) / 2
    w = torch.ones(N, device=device, dtype=torch.float32)
    # Rising edge: 0 < y < epsilon
    mask_rise = (y > 0) & (y < epsilon)
    if mask_rise.any():
        Z_plus = 2 * epsilon * (1 / (1 + 2 * y[mask_rise] - 1) + 1 / (1 - 2 * epsilon + 2 * y[mask_rise] - 1))
        w[mask_rise] = 1.0 / (torch.exp(Z_plus) + 1.0)
    # Flat region: epsilon <= y <= 1 - epsilon
    mask_flat = (y >= epsilon) & (y <= 1 - epsilon)
    w[mask_flat] = 1.0
    # Falling edge: 1 - epsilon < y < 1
    mask_fall = (y > (1 - epsilon)) & (y < 1)
    if mask_fall.any():
        Z_minus = 2 * epsilon * (1 / (1 - 2 * y[mask_fall] + 1) + 1 / (1 - 2 * epsilon - 2 * y[mask_fall] + 1))
        w[mask_fall] = 1.0 / (torch.exp(Z_minus) + 1.0)
    # Endpoints set to 0
    w[0] = 0.0
    w[-1] = 0.0
    return w

def kaiser_window_range(L: int, beta: float = 8.6, x_min: float = -1, x_max: float = 1, device: str = 'cpu') -> torch.Tensor:
    """
    Returns a Kaiser window of length L defined over an arbitrary range [x_min, x_max].
    The window values are generated by torch.kaiser_window (which is independent of the coordinate),
    so the coordinate mapping is handled externally.
    
    Args:
        L (int): Window length.
        beta (float): Kaiser beta parameter.
        x_min (float): Minimum coordinate value.
        x_max (float): Maximum coordinate value.
        device (str): Device.
    
    Returns:
        Tensor: A 1D tensor of shape [L] representing the Kaiser window.
    """
    return torch.kaiser_window(L, beta=beta, periodic=False, device=device)

# tukey_window remains as provided:
def tukey_window(window_length, alpha=0.05):
    """Generates a Tukey window."""
    if alpha < 0 or alpha > 1:
        raise ValueError("Alpha must be between 0 and 1")
    window = torch.ones(window_length)
    if alpha == 0:
        return window
    ramp = int(alpha * window_length / 2)
    if ramp == 0:
        return window
    w = torch.linspace(0, 1, ramp)
    cosine = 0.5 * (1 + torch.cos(torch.pi * (w - 1)))
    window[:ramp] = cosine
    window[-ramp:] = cosine.flip(0)
    return window

def bisquare_window(L: int, device: str = 'cpu') -> torch.Tensor:
    """
    Compute the bisquare window defined as:
      w(x) = (1 - x^2)^2, with x linearly spaced from -1 to 1.
    """
    x = torch.linspace(-1, 1, steps=L, device=device, dtype=torch.float32)
    return (1 - x**2)**2

# ============================
# QTile Class
# ============================
class QTile(torch.nn.Module):
    """
    Compute the row of Q-tiles for a single Q value and a single
    frequency for a batch of multi-channel frequency series data.
    (Matches GWpy's QTransform style.)
    
    Args:
        q:
            The Q value for the transform.
        frequency:
            The central frequency (Hz) for this Q-tile.
        duration:
            The duration (seconds) of the input frequency series.
        sample_rate:
            The sample rate (Hz) of the input time series.
        mismatch:
            The maximum fractional mismatch between neighboring tiles.
        logf:
            Whether to use log-spaced frequencies.
        energy_mode:
            If True, compute energy (magnitude squared), else amplitude.
        phase_mode:
            If True, also compute phase.
        window_param:
            Which window to use: 
              - None (default) uses the bisquare window,
              - 'hann', 'tukey', 'planck-taper', 'kaiser'
              - Or you can provide a torch.Tensor window.
        tau:
            Tapering parameter for planck-taper and tukey windows.
        beta:
            Kaiser window parameter.
    """
    def __init__(
        self,
        q: float,
        frequency: float,
        duration: float,
        sample_rate: float,
        mismatch: float,
        logf: bool = False,
        energy_mode: bool = True,
        phase_mode: bool = False,
        window_param: Optional[Union[str, torch.Tensor]] = None,
        tau: float = 1/2,
        beta: float = 8.6
    ):
        super().__init__()
        self.mismatch = mismatch
        self.q = q
        self.deltam = torch.tensor(2 * (self.mismatch / 3.0) ** (1/2.0))
        self.qprime = self.q / (11 ** (1/2.0))
        self.frequency = frequency
        self.duration = duration
        self.sample_rate = sample_rate
        self.logf = logf
        self.energy_mode = energy_mode
        self.phase_mode = phase_mode
        self.window_param = window_param  # which window to use
        self.tau = tau                    # tapering parameter (for planck-taper and tukey)
        self.beta = beta                  # Kaiser window parameter

        # Compute windowsize from frequency and duration:
        self.windowsize = 2 * int(self.frequency / self.qprime * self.duration) + 1
        pad = self.ntiles() - self.windowsize
        padding = torch.Tensor((int((pad - 1) / 2.0), int((pad + 1) / 2.0)))
        self.register_buffer("padding", padding)
        self.register_buffer("indices", self.get_data_indices())
        self.register_buffer("window", self.get_window())

    def ntiles(self):
        """Number of tiles in this frequency row."""
        tcum_mismatch = self.duration * 2 * math.pi * self.frequency / self.q
        return int(2 ** math.ceil(math.log(tcum_mismatch / self.deltam.item(), 2)))

    def _get_indices(self):
        """Returns a symmetric index array based on windowsize."""
        half = int((self.windowsize - 1) / 2)
        return torch.arange(-half, half + 1)

    def get_data_indices(self):
        """Get the index array for frequency interpolation (shifting indices to be positive)."""
        return torch.round(self._get_indices() + 1 + self.frequency * self.duration).type(torch.long)
    
    def compute_time_energy(self,window):
        """
        Compute total energy of the window in time domain (sum of squared amplitudes).
        """
        return torch.mean(window**2).item()

    def get_window(self):
        """
        Generate the window for this QTile row.
        The indices are first scaled to a frequency-like coordinate, then the window is computed.
        
        The scaling of indices:
          w_frequencies = indices / duration,
          x_frequencies = w_frequencies * (qprime / frequency)
        Then, the window function is applied to x_frequencies.
        
        Each window type uses its own energy constant A (defined as the integral of |w(x)|^2 over the canonical range)
        so that the normalization factor is:
        
          norm = (ntiles / (duration*sample_rate)) * (( qprime / (A*frequency))^(1/2))
        
        A is window design dependent, it corresponds to the area of the window 
        """
        # Compute frequency-like coordinates from indices:
        wfrequencies = self._get_indices().float() / self.duration
        xfrequencies = wfrequencies * self.qprime / self.frequency
        
        # Common geometric scaling factor:
        common_scale = self.ntiles() / (self.duration * self.sample_rate) * (self.qprime / self.frequency)**0.5
        # Now choose the window function based on window_param:
        if self.window_param is None:
            # Bisquare window:
            # For bisquare, A_bisquare = 315/128 (since integral_{-1}^{1} |(1-x^2)^2|^2 dx = 256/315 and for energy=2, factor^2 = 315/128)
            A = 128/315
            norm = common_scale * A**(-0.5)
            window = (1 - xfrequencies**2)**2 * norm
            return torch.Tensor(window)
        
        elif isinstance(self.window_param, torch.Tensor):
            w = self.window_param.flatten()
            if w.shape[0] != self.windowsize:
                w = F.interpolate(w.unsqueeze(0).unsqueeze(0), size=self.windowsize, mode='linear', align_corners=False).squeeze()
            return w
        
        elif self.window_param.lower() == 'hann':
            A = 3/8 #integral [0.5^2*(1+Cos[Pi*x])^2] from -1 to 1 dx 
            norm = common_scale * A**(-0.5)
            window=0.5*(1+torch.cos(torch.pi*xfrequencies))*norm
            return torch.Tensor(window)
        
        elif self.window_param.lower() == 'tukey':
            
            A = 8/(8-5*self.tau) #Integral [tukey window] from -1 to 1= 2-5*tau/4

            norm = common_scale * A**(-0.5)
            return tukey_window(self.windowsize, alpha= self.tau) * norm
        
        elif self.window_param.lower() == 'planck-taper':
            print(f'{self.window_param.lower()=}')
            # For Planck-taper, use the planck_taper_window_range function over [-1,1].
            window=planck_taper_window_range(self.windowsize, epsilon=self.tau, x_min=-1, x_max=1, device=self.padding.device)
            
            A = 0.811411 #self.compute_time_energy(window) #No analitic expression  for Integrate[(...)^2,{x, -1, 1}] 
                                            # as function of tau, hence we calculate normalization factor numerically as sum of squared amplitudes
                                            # we might want to refine this using one big (i.e. with many sample points) window to better estimate the integral
            norm = common_scale * A**(-0.5)
            return window * norm
        
        elif self.window_param.lower() == 'kaiser':
            # For Kaiser, use the kaiser_window_range function.
            window=kaiser_window_range(self.windowsize, beta=self.beta, x_min=-1, x_max=1, device=self.padding.device)
            A = self.compute_time_energy(window) #No analitic expression  for Integrate[(BesselI[0, beta*Sqrt[1 - x^2]]/BesselI[0, beta])^2,{x, -1, 1}] 
                                            # as function of beta, hence we calculate normalization factor numerically as sum of squared amplitudes
                                            # we might want to refine this using one big (i.e. with many sample points) window to better estimate the integral
            norm = common_scale * A**(-0.5)
            return window * norm
        
        else:
            raise ValueError(f"Unsupported window_param: {self.window_param}")

    def forward(self, fseries: torch.Tensor, norm: str = "median"):
        """
        Compute the Q-tile for the input frequency series.
        The frequency series is windowed (using the window computed above),
        padded to ensure correct overlap-add, and then transformed back to the time domain.
        
        Args:
            fseries (Tensor): Input frequency series (shape: [B, C, ...]).
            norm (str): Normalization method ('median' or 'mean').
        
        Returns:
            Tensor: Processed energy (and optionally phase) for the Q-tile.
        """
        if len(fseries.shape) > 3:
            raise ValueError("Input data has more than 3 dimensions")
        
        while len(fseries.shape) < 3:
            fseries = fseries[None]
        
        # Apply the window to the frequency series at the given indices.
        windowed = fseries.to(self.indices.device)[..., self.indices] * self.window
        left, right = self.padding
        padded = F.pad(windowed, (int(left), int(right)), mode="constant")
        wenergy = torch.fft.ifftshift(padded, dim=-1)
        tdenergy = torch.fft.ifft(wenergy)
        
        phase = None
        if self.energy_mode:
            energy = tdenergy.real**2 + tdenergy.imag**2
        else:
            energy = torch.sqrt(tdenergy.real**2 + tdenergy.imag**2)
        
        if self.phase_mode:
            phase = torch.atan2(tdenergy.imag, tdenergy.real)
        
        if norm:
            norm = norm.lower() if isinstance(norm, str) else norm
            if norm == "median":
                medians = torch.quantile(energy, q=0.5, dim=-1, keepdim=True)
                energy = energy / medians
            elif norm == "mean":
                means = torch.mean(energy, dim=-1, keepdim=True)
                energy = energy / means
        
        if self.phase_mode:
            return energy.type(torch.float32), phase
        return energy.type(torch.float32)

        
##########################################################################
# Single Q Qtransform Class
##########################################################################

class SingleQTransform(torch.nn.Module):
    """
    Compute the Q-transform for a single Q value for a batch of
    multi-channel time series data. Input data should have
    three dimensions or fewer.

    Args:
        duration:
            Length of the time series data in seconds
        sample_rate:
            Sample rate of the data in Hz
        spectrogram_shape:
            The shape of the interpolated spectrogram, specified as
            `(num_f_bins, num_t_bins)`. Because the
            frequency spacing of the Q-tiles is in log-space, the frequency
            interpolation is log-spaced as well.
        q:
            The Q value to use for the Q transform
        frange:
            The lower and upper frequency limit to consider for
            the transform. If unspecified, default values will
            be chosen based on q, sample_rate, and duration
        mismatch:
            The maximum fractional mismatch between neighboring tiles
    """

    def __init__(
        self,
        duration: float,
        sample_rate: float,
        spectrogram_shape: Tuple[int, int],
        q: float = 12,
        frange: List[float] = [0, torch.inf],
        mismatch: float = 0.2,
        logf: bool = False,
        qtiles_mode: bool =False,
        energy_mode: bool =True,
        phase_mode: bool =False,
        free_memory: bool =False,
        window_param: Optional[Union[str, torch.Tensor]] = None,
        tau: float = 1/2,
        beta: float = 8.6
        
    ):
        super().__init__()
        self.q = q
        self.spectrogram_shape = spectrogram_shape
        self.frange = frange
        self.duration = duration
        self.mismatch = mismatch
        self.logf= logf
        self.qtiles_mode=qtiles_mode # Allow for Qtile computation only (no interpolation). Very useful for ML applications!
        self.energy_mode=energy_mode # Allow for returning normalized amplitude instead of energy.
        self.phase_mode=phase_mode # Allow for returning also the phase of Qtransform. Very useful for ML applications!
        self.free_memory =free_memory # wheter to free allocated but unused memory after each loop. Time consumig but enables larger batches for big datasets
        self.window_param = window_param
        self.tau = tau
        self.beta = beta
        
        
        qprime = self.q / 11 ** (1 / 2.0)
        if self.frange[0] <= 0:  # set non-zero lower frequency
            self.frange[0] = 50 * self.q / (2 * torch.pi * duration)
        if math.isinf(self.frange[1]):  # set non-infinite upper frequency
            self.frange[1] = sample_rate / 2 / (1 + 1 / qprime)
        self.freqs = self.get_freqs()
        self.qtile_transforms = torch.nn.ModuleList(
            [
                QTile(
                self.q, freq, self.duration, sample_rate, self.mismatch,
                self.logf, self.energy_mode, self.phase_mode,window_param=self.window_param,tau=self.tau,beta=self.beta
            )
                for freq in self.freqs
            ]
        )
        self.qtiles = None
        self.phase_qtiles = None  # New attribute to store phase Qtiles

    def get_freqs(self):
        """
        Calculate the frequencies that will be used in this transform.
        For each frequency, a `QTile` is created.
        """
        minf, maxf = self.frange
        fcum_mismatch = (
            math.log(maxf / minf) * (2 + self.q**2) ** (1 / 2.0) / 2.0
        )
        deltam = 2 * (self.mismatch / 3.0) ** (1 / 2.0)
        nfreq = int(max(1, math.ceil(fcum_mismatch / deltam)))
        fstep = fcum_mismatch / nfreq
        fstepmin = 1 / self.duration

        freq_base = math.exp(2 / ((2 + self.q**2) ** (1 / 2.0)) * fstep)
        freqs = torch.Tensor([freq_base ** (i + 0.5) for i in range(nfreq)])
        freqs = (minf * freqs // fstepmin) * fstepmin
        return torch.unique(freqs)

    def get_max_energy(
        self, fsearch_range: List[float] = None, dimension: str = "both"
    ):
        """
        Gets the maximum energy value among the QTiles. The maximum can
        be computed across all batches and channels, across all channels,
        across all batches, or individually for each channel/batch
        combination. This could be useful for allowing the use of different
        Q values for different channels and batches, but the slicing would
        be slow, so this isn't used yet.

        Optionally, a pair of frequency values can be specified for
        `fsearch_range` to restrict the frequencies in which the maximum
        energy value is sought.
        """
        allowed_dimensions = ["both", "neither", "channel", "batch"]
        if dimension not in allowed_dimensions:
            raise ValueError(f"Dimension must be one of {allowed_dimensions}")

        if self.qtiles is None:
            raise RuntimeError(
                "Q-tiles must first be computed with .compute_qtiles()"
            )

        if fsearch_range is not None:
            start = min(torch.argwhere(self.freqs > fsearch_range[0]))
            stop = min(torch.argwhere(self.freqs > fsearch_range[1]))
            qtiles = self.qtiles[start:stop]
        else:
            qtiles = self.qtiles

        if dimension == "both":
            return max([torch.max(qtile) for qtile in qtiles])

        max_across_t = [torch.max(qtile, dim=-1).values for qtile in qtiles]
        max_across_t = torch.stack(max_across_t, dim=-1)
        max_across_ft = torch.max(max_across_t, dim=-1).values

        if dimension == "neither":
            return max_across_ft
        if dimension == "channel":
            return torch.max(max_across_ft, dim=-2).values
        if dimension == "batch":
            return torch.max(max_across_ft, dim=-1).values

    def compute_qtiles(self, X: torch.Tensor, norm: str = "median"):
        """
        Take the FFT of the input timeseries and calculate the transform
        for each `QTile`
        """
        # Computing the FFT with the same normalization and scaling as GWpy
        X = torch.fft.rfft(X, norm="forward")
        X[..., 1:] *= 2
        # Compute Qtiles, handling phase_mode
        if self.phase_mode:
            self.qtiles = []
            self.phase_qtiles = []
            for qtile in self.qtile_transforms:
                energy, phase = qtile(X, norm)
                self.qtiles.append(energy)
                self.phase_qtiles.append(phase)
        else:
            self.qtiles = [qtile(X, norm) for qtile in self.qtile_transforms]
    
    def interpolate(self, num_f_bins, num_t_bins, device):

        if self.qtiles is None:
            raise RuntimeError(
                "Q-tiles must first be computed with .compute_qtiles()"
            )

        xout = torch.arange(0.0,0.0+self.duration, step=self.duration / num_t_bins)
        
        # Interpolate along the time dimension using natural cubic spline

        #define NN for 1d interpolation

        spline_interpolate_batch=SplineInterpolate1D_batch(num_t_bins).to(device)
        
        #perfrom 1d spline interpolation in batches
        
        time_interp_tiles=spline_interpolate_batch(Z=self.qtiles,xmin=0.0,xmax=self.duration,xout=xout)
        
        #Inteprolate along both the time and frequency dimension using natural bicubic spline
        if self.logf:
            yout = torch.tensor(np.geomspace(
                self.frange[0],
                self.frange[1],
                num=num_f_bins,))
        else:
            yout = torch.arange(
                self.frange[0], self.frange[1],(self.frange[1] - self.frange[0])/num_f_bins )
        

        #define NN for 2d interpolation
        spline_interpolate_2d=SplineInterpolate2D(num_t_bins=num_t_bins, num_f_bins=num_f_bins,logf=self.logf,frange=self.frange).to(device)

        #interpolate Qtransform
        resampled=spline_interpolate_2d(time_interp_tiles.transpose(2,3),xin=xout,xout=xout,yin=self.freqs,yout=yout)    


        # Interpolate phase if required
        if self.phase_mode:
            # 1D interpolation for phase
            phase_time = spline_interpolate_batch(
                self.phase_qtiles, xmin=0, xmax=self.duration, xout=xout
            )
            # 2D interpolation
            phase_interp = spline_interpolate_2d(
                phase_time.transpose(2, 3), xin=xout, xout=xout,
                yin=self.freqs.to(device), yout=yout
            )
            
            
            return torch.stack([resampled, phase_interp], dim=2).detach().cpu()  #to(device)

        return resampled.detach().cpu()

    def forward(
        self,
        X: torch.Tensor,
        norm: str = "median",
        spectrogram_shape: Optional[Tuple[int, int]] = None,
    ):
        """
        Compute the Q-tiles and interpolate

        Args:
            X:
                Time series of data. Should have the duration and sample rate
                used to initialize this object. Expected input shape is
                `(B, C, T)`, where T is the number of samples, C is the number
                of channels, and B is the number of batches. If less than
                three-dimensional, axes will be added during Q-tile
                computation.
            norm:
                The method of interpolation used by each QTile
            spectrogram_shape:
                The shape of the interpolated spectrogram, specified as
                `(num_f_bins, num_t_bins)`. Because the
                frequency spacing of the Q-tiles is in log-space, the frequency
                interpolation is log-spaced as well. If not given, the shape
                used to initialize the transform will be used.

        Returns:
            The interpolated Q-transform for the batch of data. Output will
            have one more dimension than the input
        """

        if spectrogram_shape is None:
            spectrogram_shape = self.spectrogram_shape
        num_f_bins, num_t_bins = spectrogram_shape
        self.compute_qtiles(X, norm)
        
        # Allow for Qtile computation only. Very useul in many ML applications!
        if self.qtiles_mode:
            if self.phase_mode:
                return self.qtiles, self.phase_qtiles
            return self.qtiles
        
        # Otherwise interpolate and return
        interpolated = self.interpolate(num_f_bins, num_t_bins, X.device)
        return interpolated

##########################################################################
# Multi Q Qtransform Class
##########################################################################

class QScan(torch.nn.Module):
    """
    Calculate the Q-transform of a batch of multi-channel
    time series data for a range of Q values and return
    the interpolated Q-transform with the highest energy.

    Args:
        duration:
            Length of the time series data in seconds
        sample_rate:
            Sample rate of the data in Hz
        spectrogram_shape:
            The shape of the interpolated spectrogram, specified as
            `(num_f_bins, num_t_bins)`. Because the
            frequency spacing of the Q-tiles is in log-space, the frequency
            interpolation is log-spaced as well.
        qrange:
            The lower and upper values of Q to consider. The
            actual values of Q used for the transforms are
            determined by the `get_qs` method
        frange:
            The lower and upper frequency limit to consider for
            the transform. If unspecified, default values will
            be chosen based on q, sample_rate, and duration
        mismatch:
            The maximum fractional mismatch between neighboring tiles
    """

    def __init__(
        self,
        duration: float,
        sample_rate: float,
        spectrogram_shape: Tuple[int, int],
        qrange: List[float] = [4, 64],
        frange: List[float] = [0, torch.inf],
        mismatch: float = 0.2,
        energy_mode: bool = True,
        phase_mode: bool = False
    ):
        super().__init__()
        self.qrange = qrange
        self.mismatch = mismatch
        self.qs = self.get_qs()
        self.frange = frange
        self.spectrogram_shape = spectrogram_shape
        self.energy_mode = energy_mode
        self.phase_mode = phase_mode

        # Initialize Q-transforms with configuration
        self.q_transforms = torch.nn.ModuleList([
            SingleQTransform(
                duration=duration,
                sample_rate=sample_rate,
                spectrogram_shape=spectrogram_shape,
                q=q,
                frange=self.frange.copy(),
                mismatch=self.mismatch,
                energy_mode=self.energy_mode,
                phase_mode=self.phase_mode
            ) for q in self.qs
        ])

    def get_qs(self):
        """Calculate Q values to scan"""
        deltam = 2 * (self.mismatch / 3.0) ** (1 / 2.0)
        cumum = math.log(self.qrange[1] / self.qrange[0]) / 2 ** (1 / 2.0)
        nplanes = int(max(math.ceil(cumum / deltam), 1))
        dq = cumum / nplanes
        qs = [
            self.qrange[0] * math.exp(2 ** (1 / 2.0) * dq * (i + 0.5))
            for i in range(nplanes)
        ]
        return qs

    def forward(
        self,
        X: torch.Tensor,
        fsearch_range: List[float] = None,
        norm: str = "median",
        spectrogram_shape: Optional[Tuple[int, int]] = None,
    ):
        """
        Compute the set of QTiles for each Q transform and determine which
        has the highest energy value. Interpolate and return the
        corresponding set of tiles.

        Args:
            X:
                Time series of data. Should have the duration and sample rate
                used to initialize this object. Expected input shape is
                `(B, C, T)`, where T is the number of samples, C is the number
                of channels, and B is the number of batches. If less than
                three-dimensional, axes will be added during Q-tile
                computation.
            fsearch_range:
                The lower and upper frequency values within which to search
                for the maximum energy
            norm:
                The method of interpolation used by each QTile
            spectrogram_shape:
                The shape of the interpolated spectrogram, specified as
                `(num_f_bins, num_t_bins)`. Because the
                frequency spacing of the Q-tiles is in log-space, the frequency
                interpolation is log-spaced as well. If not given, the shape
                used to initialize the transform will be used.

        Returns:
            An interpolated Q-transform for the batch of data. Output will
            have one more dimension than the input
        """
        # Compute all Q-transforms
        for transform in self.q_transforms:
            transform.compute_qtiles(X, norm)
        
        # Find Q-transform with maximum energy
        idx = torch.argmax(
            torch.Tensor([
                transform.get_max_energy(fsearch_range=fsearch_range)
                for transform in self.q_transforms
            ])
        )
        
        # Interpolate and return best transform
        spectrogram_shape = spectrogram_shape or self.spectrogram_shape
        num_f_bins, num_t_bins = spectrogram_shape
        return self.q_transforms[idx].interpolate(num_f_bins, num_t_bins, X.device)